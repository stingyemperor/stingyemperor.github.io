<!DOCTYPE html>
<html lang="en">
<head>
  <title>Ray Tracing"</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
  <script src="glsl.js"></script>
  <script>

    function addColorToGui(gui, props, name, func, scope) {
      const controller = gui.addColor(props, name);
      controller.onChange(func.bind(scope));
    }

    function addToGui(gui, props, name, func, scope, min, max, step) {
      const controller = gui.add(props, name, min, max, step);
      controller.onChange(func.bind(scope));
    }

    document.addEventListener('DOMContentLoaded', function() {

      const glsl = new GLSL({
        canvasId: 'canvas',
        fragmentShaderSource: `#version 300 es
        precision mediump float;
        
                                                        //============================================================================
                                                        //uniforms.
                                                        //============================================================================
        
        uniform float uTime;
        uniform vec2 uResolution;
        uniform vec2 uMouse;
        uniform bool uMousePressed;
        
        uniform float uCameraPosition;
        uniform float uCameraHeight;
        uniform float uFieldOfView;
        uniform float uFocus;
        uniform float uAperture;
        uniform vec3 uSkyColor;
        uniform vec3 uSphere1Color;
        uniform vec3 uGroundColor;
        uniform vec3 uSphere2Color;
        uniform vec3 uMetalColor;
        uniform float uFuzziness;
        uniform int uSamples;
        uniform sampler2D uRandomTexture;
        uniform sampler2D uFloorTexture;
        uniform sampler2D uFloorNormal;
        uniform sampler2D uSphereEnvironment;
        uniform float uLightX;
        uniform float uLightY;
        uniform float uLightZ;
        uniform samplerCube uSkyBox;
        uniform mat4 uViewDirectionProjectionInverse;
        uniform int uFinalGatheringVersion; // 0 for ambient, 1 for env. ill., 2 for color bleeding, 3 for caustics
        
        in vec4 vPosition;
        out vec4 fragmentColor;
        
                                                                #define PI 3.14159265359
                                                                #define TWO_PI 6.28318530718
        
                                                                #define NUM_OF_FACES 6
                                                                #define NUM_OF_VERTICES 8
        
                                                        //============================================================================
                                                        //Structs
                                                        //============================================================================        
        struct HitInfo {
            vec3 pos;
            vec3 normal;
            int reflectType;
            float u, v;
        };
        
        struct Light {
            vec3 position;
            vec3 direction;
            vec3 color;
            float intensity;
            vec3 uvec;
            vec3 vvec;
            int vsteps;
            int usteps;
            int samples;
        };
        
        struct Material {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            float shininess;
            float refractionCoeff;
            float refractionIndex;
        };
        
        struct Mesh {
            int numFaces;
            int numTriangles;
            int[NUM_OF_FACES] faceIndex;
            int[NUM_OF_VERTICES] vertIndex;
            vec3[NUM_OF_VERTICES] vertices;
            vec3[NUM_OF_FACES] normals;
            vec2[100] st;
        };
                                                        //============================================================================
                                                        //Randomness.
                                                        //============================================================================
        
        float random(float x) {
            return fract(sin(x) * 4245.324);
        }
        
        float random(vec2 x) {
            return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        vec2 random2(vec2 x) {
            return fract(sin(vec2(dot(x, vec2(12.9898, 78.233)), dot(x, vec2(19.392, 59.434)))) * 43758.5453123);
        }
        
        float randseed = 0.423;
        
        float random() {
            randseed += 0.01;
            return random(randseed);
        }
        
        int randIndex() {
        
            return int(gl_FragCoord.x * fract(sin(dot(gl_FragCoord.xy * 0.01, vec2(19.342, 54.342)) * 3244.4234)) * 256.0 * 256.0);
        }
        
        vec2 randompos() {
            int randomindex = randIndex();
            int h = randomindex / 256;
            int w = randomindex - h * 256;
            return vec2(float(w) / 256.0, float(h) / 256.0);
        }
        vec3 random3() {
            int randomindex = randIndex();
            randomindex += 1;
            return texture(uRandomTexture, randompos()).xyz;
        }
        vec2 random2() {
            return random3().xy;
        }
        float random4() {
            return random3().x;
        }
        
        vec3 random_in_unit_sphere() {
            vec3 v;
            for(int i = 0; i < 100; i++) {
                randseed += 0.01;
                float rx = random(randseed);
                randseed += 0.01;
                float ry = random(randseed);
                randseed += 0.01;
                float rz = random(randseed);
                v = vec3(rx, ry, rz) * 2.0 - 1.0;
                if(length(v) <= 1.0)
                    break;
            }
            return v;
        }
        
        vec2 random_on_unit_disk() {
            vec2 v;
            for(int i = 0; i < 100; i++) {
                randseed += 0.01;
                float rx = random(randseed);
                randseed += 0.01;
                float ry = random(randseed);
                v = vec2(rx, ry) * 2.0 - 1.0;
                if(length(v) <= 1.0)
                    break;
            }
            return v;
        }
        
        vec3 randomCosineHemisphere() {
            float r1 = random4();
            float r2 = random4();
            float z = sqrt(1.0 - r2);
            float phi = TWO_PI * r1;
            float x = cos(phi) * sqrt(r2);
            float y = sin(phi) * sqrt(r2);
            return vec3(x, y, z);
        }
        
        //============================================================================
        //Camera
        //============================================================================
        
        mat3 camera(in vec3 pos, in vec3 tar, in vec3 up) {
            vec3 cz = normalize(tar - pos);
            vec3 cx = normalize(cross(cz, normalize(up)));
            vec3 cy = normalize(cross(cx, cz));
            return mat3(cx, cy, cz);
        }
        
        //============================================================================
        //Ray
        //============================================================================
        
        void ray(in mat3 cam, in vec3 origin, in vec2 uv, in float vfov, in float aspect, inout vec3 rpos, inout vec3 rdir) {
            float theta = vfov * PI / 180.0;
            float h = tan(theta / 2.0);
            float w = h * aspect;
            vec3 offset = cam * vec3(random_on_unit_disk(), 0.0) * uAperture;
            rpos = origin + offset;
            rdir = normalize(origin + cam * uFocus * vec3(w * uv.x, h * uv.y, 1.0) - rpos);
        }
        
        //============================================================================
        //Plane
        //============================================================================
        vec2 planeMap(vec3 point) {
            vec3 normal = vec3(0.0, 1.0, 0.0);
            vec3 u = normalize(vec3(normal.y, -normal.x, 0));
            vec3 v = cross(normal, u);
            float hu = dot(u, point);
            float hv = dot(v, point);
            return vec2(hu, hv);
        }
        
        bool plane(in vec3 pos, in vec3 dir, in float y, in int reflectType, in float tmin, inout float tmax, inout HitInfo info) {
            if(dir.y == 0.0)
                return false;
            float tt = (y - pos.y) / dir.y;
            if(tt > tmin && tt < tmax) {
                info.pos = pos + tt * dir;
        
                vec2 uv = planeMap(info.pos);
                // vec3 tempN = texture(uFloorNormal, uv).xyz;
                info.normal = vec3(0.0, 1.0, 0.0);
                // info.normal = tempN;
                info.reflectType = reflectType;
                info.u = uv.x;
                info.v = uv.y;
                return true;
            }
            return false;
        }
        
        bool plane(in vec3 pos, in vec3 dir, in float y, in float tmin, in float tmax) {
            if(dir.y == 0.0)
                return false;
            float tt = (y - pos.y) / dir.y;
            if(tt > tmin && tt < tmax) {
                return true;
            }
            return false;
        }
        
        bool IntersectPlane(float A, float B, float C, float D, in int reflectType, vec3 pos, vec3 dir, in float tmin, inout float tmax, inout HitInfo info) {
            vec3 N = vec3(A, B, C);
            float NRd = dot(N, dir);
            float NRo = dot(N, pos);
            float t0 = (-D - NRo) / NRd;
            if(t0 < tmin || t0 > tmax)
                return false;
        
            // We have a hit -- output results.
            tmax = t0;
            info.pos = pos + t0 * dir;
            vec2 uv = planeMap(info.pos);
            // vec3 tempN = texture(uFloorNormal, uv).xyz;
            // info.normal = tempN;
            info.normal = vec3(0.0, 1.0, 0.0);
            info.reflectType = reflectType;
            info.u = uv.x;
            info.v = uv.y;
            return true;
        }
        
        bool IntersectPlane(float A, float B, float C, float D, in int reflectType, vec3 pos, vec3 dir, in float tmin, in float tmax) {
            vec3 N = vec3(A, B, C);
            float NRd = dot(N, dir);
            float NRo = dot(N, pos);
            float t0 = (-D - NRo) / NRd;
            if(t0 < tmin || t0 > tmax)
                return false;
            return true;
        }
        
        bool rectZX(in float z1, in float x1, in float z2, in float x2, in float y, in float tmin, inout float tmax, vec3 pos, vec3 dir, in int reflectType, inout HitInfo hitInfo) {
            float t = (y - pos.y) / dir.y;
            vec3 p = pos + t * dir;
            if(t < tmin || t > tmax || p.z < z1 || p.z > z2 || p.x < x1 || p.x > x2)
                return false;
            tmax = t;
            vec2 uv = planeMap(hitInfo.pos);
            // vec3 tempN = texture(uFloorNormal, uv).xyz;
            // hitInfo.normal = tempN;
            hitInfo.pos = p;
            hitInfo.u = uv.x;
            hitInfo.v = uv.y;
            hitInfo.normal = vec3(0.0, 1.0, 0.0);
            hitInfo.reflectType = reflectType;
            return true;
        }
        
        bool rectZX(in float z1, in float x1, in float z2, in float x2, in float y, in float tmin, inout float tmax, vec3 pos, vec3 dir) {
            float t = (y - pos.y) / dir.y;
            vec3 p = pos + t * dir;
            if(t < tmin || t > tmax || p.z < z1 || p.z > z2 || p.x < x1 || p.x > x2)
                return false;
            tmax = t;
            return true;
        }
        
                                                        //============================================================================
                                                        //Sphere
                                                        //============================================================================
        
        bool sphere(in vec3 pos, in vec3 dir, in vec3 center, in float radius, in int reflectType, in float tmin, inout float tmax, inout HitInfo info) {
            vec3 oc = pos - center;
            float a = dot(dir, dir);
            float b = dot(oc, dir);
            float c = dot(oc, oc) - radius * radius;
            float dis = b * b - a * c;
        
            if(dis < 0.0)
                return false;
        
            float tt = (-b - sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                tmax = tt;
                info.pos = pos + tt * dir;
                info.normal = normalize(info.pos - center);
                info.reflectType = reflectType;
                return true;
            }
            tt = (-b + sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                tmax = tt;
                info.pos = pos + tt * dir;
                info.normal = normalize(info.pos - center);
                info.reflectType = reflectType;
                return true;
            }
        
            return false;
        }
        
        bool sphere(in vec3 pos, in vec3 dir, in vec3 center, in float radius, in float tmin, in float tmax) {
            vec3 oc = pos - center;
            float a = dot(dir, dir);
            float b = dot(oc, dir);
            float c = dot(oc, oc) - radius * radius;
            float dis = b * b - a * c;
        
            if(dis < 0.0)
                return false;
        
            float tt = (-b - sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
        
                return true;
            }
            tt = (-b + sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
        
                return true;
            }
        
            return false;
        }
        
        bool envSphere(in vec3 pos, in vec3 dir, in vec3 center, in float radius, in float tmin, in float tmax, out vec3 env) {
            vec3 oc = pos - center;
            float a = dot(dir, dir);
            float b = dot(oc, dir);
            float c = dot(oc, oc) - radius * radius;
            float dis = b * b - a * c;
        
            if(dis < 0.0)
                return false;
        
            float tt = (-b - sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                env = pos + tt * dir;
                return true;
            }
            tt = (-b + sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                env = pos + tt * dir;
                return true;
            }
        
            return false;
        }
        
        vec2 sphereMap(vec3 point, vec3 center, float radius) {
            float theta = atan(-(point.z - center.z), point.x - center.x);
            float u = (theta + PI) / TWO_PI;
            float phi = acos(-(point.y - center.y) / radius);
            float v = phi / PI;
        
            return vec2(u, v);
        }
        
        const float POS_RADIUS = 3.0;
        const vec3 SPHERE_POS1 = vec3(POS_RADIUS * cos(0.0), 2.0, POS_RADIUS * sin(0.0));
        const vec3 SPHERE_POS2 = vec3(POS_RADIUS * -cos(TWO_PI / 3.0), 2.0, POS_RADIUS * sin(TWO_PI / 3.0));
        const vec3 SPHERE_POS3 = vec3(POS_RADIUS * cos(TWO_PI / 3.0 * 2.0), 2.0, POS_RADIUS * sin(TWO_PI / 3.0 * 2.0));
        const vec3 SPHERE_POS4 = vec3(0.0, 0.0, 0.0);
        const float SPHERE_RADIUS = 2.0;
        
                                                        //============================================================================
                                                        //Triangle
                                                        //============================================================================
        
        bool triangle(in vec3 pos, in vec3 dir, vec3 v0, vec3 v1, vec3 v2, out HitInfo info, in int reflectType) {
        
            float epsilon = 0.001;
            vec3 e1 = v1 - v0;
            vec3 e2 = v2 - v0;
            vec3 h = cross(dir, e2);
        
            float a = dot(e1, h);
        
            if(a < epsilon && a > epsilon) {
                return false;
            }
        
            float f = 1.0 / a;
            vec3 s = pos - v0;
        
            float u = f * dot(s, h);
        
            if(u < 0.0 || u > 1.0) {
                return false;
            }
        
            vec3 q = cross(s, e1);
            float v = f * dot(dir, q);
        
            if(v < 0.0 || u + v > 1.0) {
                return false;
            }
        
            float t = f * dot(e2, q);
        
            info.pos = pos + t * dir;
            info.normal = cross(e1, e2);
            info.reflectType = reflectType;
        
            if(t > epsilon) {
                return true;
            }
        
            return true;
        }
        
        bool triangle(in vec3 pos, in vec3 dir, vec3 v0, vec3 v1, vec3 v2) {
        
            float epsilon = 0.001;
            vec3 e1 = v1 - v0;
            vec3 e2 = v2 - v0;
            vec3 h = cross(dir, e2);
        
            float a = dot(e1, h);
        
            if(a < epsilon && a > epsilon) {
                return false;
            }
        
            float f = 1.0 / a;
            vec3 s = pos - v0;
        
            float u = f * dot(s, h);
        
            if(u < 0.0 || u > 1.0) {
                return false;
            }
        
            vec3 q = cross(s, e1);
            float v = f * dot(dir, q);
        
            if(v < 0.0 || u + v > 1.0) {
                return false;
            }
        
            float t = f * dot(e2, q);
        
            if(t > epsilon) {
                return true;
            }
        
            return true;
        }
        
        int numTriangles(inout Mesh mesh, out int k, out int maxVertIndex, out int[100] triangleIndex, out vec2[100] texCoordinate) {
        
            k = 0;
            maxVertIndex = 0;
        
            for(int i = 0; i < mesh.numFaces; i++) {
                mesh.numTriangles += mesh.faceIndex[i] - 2;
                for(int j = 0; j < mesh.faceIndex[i]; j++) {
                    if(mesh.vertIndex[k + j] > maxVertIndex) {
                        maxVertIndex = mesh.vertIndex[k + j];
                    }
        
                    k += mesh.faceIndex[i];
                }
            }
        
            maxVertIndex += 1;
        
            vec3[100] P;
        
            for(int i = 0; i < maxVertIndex; i++) {
                P[i] = mesh.vertices[i];
            }
        
            int l = 0;
        
            vec3[100] N;
            for(int i = 0, k = 0; i < mesh.numFaces; i++) {
                for(int j = 0; j < mesh.faceIndex[i] - 2; j++) {
                    triangleIndex[l] = mesh.vertIndex[k];
                    triangleIndex[l + 1] = mesh.vertIndex[k + j + 1];
                    triangleIndex[l + 2] = mesh.vertIndex[k + j + 2];
                    texCoordinate[l] = mesh.st[k];
                    texCoordinate[l + 1] = mesh.st[k + j + 1];
                    texCoordinate[l + 2] = mesh.st[k + j + 2];
        
                    l += 3;
                }
                k += mesh.faceIndex[i];
            }
        
            return 0;
        }

        
        //============================================================================
        //Intersection
        //============================================================================
        // for objects
        bool intersect(in vec3 pos, in vec3 dir, inout HitInfo info, Light light) {
            float tmin = 0.00001;
            float tmax = 10000.0;
            bool hit = false;
            hit = sphere(pos, dir, SPHERE_POS3, SPHERE_RADIUS, 1, tmin, tmax, info) || hit;
            hit = sphere(pos, dir, SPHERE_POS2, SPHERE_RADIUS, 2, tmin, tmax, info) || hit;
            hit = IntersectPlane(0.0, 1.0, 0.0, 0.0, 0, pos, dir, tmin, tmax, info) || hit;
        
            vec3 v0 = vec3(-5.0, 5.0, 5.0);
            vec3 v1 = vec3(-5.0, -5.0, 5.0);
            vec3 v2 = vec3(5.0, -5.0, 5.0);
            return hit;
        }

        // for final gathering (no light parameter)
        bool intersect(in vec3 pos, in vec3 dir, inout HitInfo info) {
            float tmin = 0.00001;
            float tmax = 10000.0;
            bool hit = false;
            hit = sphere(pos, dir, SPHERE_POS3, SPHERE_RADIUS, 1, tmin, tmax, info) || hit;
            hit = sphere(pos, dir, SPHERE_POS2, SPHERE_RADIUS, 1, tmin, tmax, info) || hit;
        
            vec3 v0 = vec3(-5.0, 5.0, 5.0);
            vec3 v1 = vec3(-5.0, -5.0, 5.0);
            vec3 v2 = vec3(5.0, -5.0, 5.0);
            return hit;
        }
        
        // for shadows
        bool intersect(in vec3 pos, in vec3 dir, float tMax) {
            float tmin = 0.00001;
            bool hit = false;
            hit = sphere(pos, dir, SPHERE_POS2, SPHERE_RADIUS, tmin, tMax) || hit;
            hit = sphere(pos, dir, SPHERE_POS3, SPHERE_RADIUS, tmin, tMax) || hit;
            hit = IntersectPlane(0.0, 1.0, 0.0, 0.0, 0, pos, dir, tmin, tMax) || hit;
        
            vec3 v0 = vec3(-5.0, 5.0, 5.0);
            vec3 v1 = vec3(-5.0, -5.0, 5.0);
            vec3 v2 = vec3(5.0, -5.0, 5.0);
            return hit;
        }
        
        //============================================================================
        //Refraction
        //============================================================================
        
        float schlick(float cosine, float ref) {
            float r0 = (1.0 - ref) / (1.0 + ref);
            r0 = r0 * r0;
            return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
        }
        
        //============================================================================
        //Lighting
        //============================================================================
        
        Light light() {
        
            Light light;
            light.position = vec3(6.0, 8.0, 8.0) + vec3(uLightX, uLightY, uLightZ);
            light.color = vec3(1.0, 1.0, 0.6);
            light.intensity = 1.0;
            light.usteps = 6;
            light.vsteps = 6;
            light.uvec = light.position + vec3(0, 0, 4);
            light.vvec = light.position + vec3(0, 4, 0);
            light.samples = light.usteps * light.vsteps;
        
            return light;
        }
        
        Light fakeSphericalLight() {
            Light light;
        
            return light;
        }
        
                                //Cells are defined by u and v
        
        vec3 pointOnLight(Light light, float u, float v) {
        
            return light.position + light.uvec * (u + random4()) + light.vvec * (v + random());
        
        }
        
        bool pointInShadow(vec3 lightPoint, HitInfo info) {
        
            vec3 shadowRayOrigin = info.pos;
            vec3 shadowRayDirection = normalize(lightPoint - info.pos);
            float dist = length(lightPoint - info.pos);
            if(intersect(shadowRayOrigin, shadowRayDirection, dist)) {
                return true;
            } else {
                return false;
            }
        
            return true;
        }
        
        float intensityAt(Light light, HitInfo info, out bool shadow, vec3 pos, Material material, out vec3 color) {
            float total = 0.0;
            shadow = false;
            vec3 sum = vec3(0.0);
            for(int v = 0; v < light.vsteps; v++) {
                for(int u = 0; u < light.usteps; u++) {
        
                    vec3 lightPosition = pointOnLight(light, float(u), float(v));
        
                    vec3 L = normalize(lightPosition - info.pos);
                    vec3 N = normalize(info.normal);
                    vec3 V = normalize(pos - info.pos);
        
                    vec3 R = reflect(-L, N);
                    float NdotL = max(dot(N, L), 0.0);
                    float RdotV = max(dot(R, V), 0.0);
                    float RfotVpown = (RdotV == 0.0) ? 0.0 : pow(RdotV, material.shininess);
        
                    sum = sum + NdotL * material.diffuse;
                    sum = sum + RfotVpown * material.specular;
        
                    if(!pointInShadow(lightPosition, info)) {
                        total = total + 1.0;
                        shadow = true;
                    }
                }
            }
        
            color = (material.ambient + (sum / float(light.samples)) * light.intensity)*light.color;
            return total / float(light.samples);
        }
        
        vec3 phongShading(vec3 N, vec3 L, vec3 V, Light light, Material material, HitInfo info, bool shadow) {
        
                    // if(shadow) {
                    //     return material.ambient ;
                    // }
            vec3 R = reflect(-L, N);
            float NdotL = max(dot(N, L), 0.0);
            float RdotV = max(dot(R, V), 0.0);
            float RfotVpown = (RdotV == 0.0) ? 0.0 : pow(RdotV, material.shininess);
        
            return (material.ambient + NdotL * material.diffuse + RfotVpown * material.specular) * light.color;
        }
        
                                                        //============================================================================
                                                        //Materials
                                                        //============================================================================
        Material plane(vec3 diffuse) {
            Material plane;
            plane.diffuse = diffuse;
            plane.ambient = 0.1 * diffuse;
            plane.specular = 3.0 * diffuse;
            plane.shininess = 64.0;
        
            return plane;
        }
        
        Material sphere(vec3 diffuse) {
            Material sphere;
        
            sphere.diffuse = diffuse;
            sphere.ambient = 0.2 * sphere.diffuse;
            sphere.specular = 2.0 * sphere.diffuse;
            sphere.shininess = 64.0;
            return sphere;
        }
        
        Material mirror() {
            Material mirror;
            mirror.diffuse = vec3(0.5, 0.5, 0.5);
            mirror.ambient = 0.2 * mirror.diffuse;
            mirror.specular = 2.0 * mirror.specular;
            mirror.shininess = 64.0;
            return mirror;
        }
        
        //============================================================================
        //Ray Tracer
        //============================================================================
        vec3 trace(in vec3 pos, in vec3 dir, in Light light) {
        
            // for now, hardcode geodesic sphere
            vec3 geodesic[12];
            geodesic[0] = vec3(0.525731, 0, 0.850651);
            geodesic[1] = vec3(0, 0.850651, 0.525731);
            geodesic[2] = vec3(-0.525731, 0, 0.850651);
            geodesic[3] = vec3(0, -0.850651, 0.525731);
            geodesic[4] = vec3(0.525731, 0, -0.850651);
            geodesic[5] = vec3(0, -0.850651, -0.525731);
            geodesic[6] = vec3(-0.525731, 0, -0.850651);
            geodesic[7] = vec3(0, 0.850651, -0.525731);
            geodesic[8] = vec3(0.850651, -0.525731, 0);
            geodesic[9] = vec3(0.850651, 0.525731, 0);
            geodesic[10] = vec3(-0.850651, 0.525731, 0);
            geodesic[11] = vec3(-0.850651, -0.525731, 0);


            HitInfo info;
            vec3 c = vec3(0.5);
        
            for(int i = 0; i < 1; i++) { // why 3 times? changed to 1 time
                if(intersect(pos, dir, info, light)) {
                    bool shadow = false;
                    vec3 L = normalize(light.position - info.pos);
                    vec3 N = normalize(info.normal);
                    vec3 V = normalize(pos - info.pos);
                    float intense;
                    vec3 shadowRayOrigin = info.pos;
        
                    vec3 shadowRayDirection = L;
                    float dist = length(light.position - info.pos);
        
                    if(info.reflectType == 5) { // 
                        Material sphere = sphere(uSphere1Color);
        
                        intense = intensityAt(light, info, shadow, pos, sphere, c);
                        c = c * intense;
                    }
        
                    if(info.reflectType == 0) { // ground
        
                        vec2 uv;
                        uv.x = info.u;
                        uv.y = info.v;
                        // vec3 tempC = texture(uFloorTexture, uv).xyz;
                        Material plane = plane(uGroundColor);
        
                        intense = intensityAt(light, info, shadow, pos, plane, c);
                        c = c * intense;

                    } else if(info.reflectType == 1 || info.reflectType == 2) { // lambertian
                        // ONLY ONE USED FOR PROJECT 9
                        if (info.reflectType == 1) { // if sphere 1, apply its color
                            Material sphere = sphere(uSphere1Color);
                            intense = intensityAt(light, info, shadow, pos, sphere, c);
                            c = c * intense;
                        }
                        else { // if sphere 2, apply its color
                            Material sphere = sphere(uSphere2Color);
                            intense = intensityAt(light, info, shadow, pos, sphere, c);
                            c = c * intense;                        }
                        }

                        if (uFinalGatheringVersion == 4) { // default
                            continue;
                        }

                        // based on slides from final gathering
                        // iterate through different directions
                        HitInfo info2;
                        vec3 wc = c;
                        float w = 1.0;
                        for (int i = 0; i < 12; ++i) {
                            // Nh denote unit shading normal (N?)
                            vec3 nplusr = N + geodesic[i];
                            vec3 nhprime = (nplusr)/length(nplusr);

                            // compute weight of ray
                            float costheta = dot(N, nhprime);

                            // if ray goes into the sphere, skip
                            if (costheta < 0.0) continue;
                        
                            // shoot ray and look for hit from info.pos in direction of nhprime
                            bool gathering_intersect = intersect(info.pos, nhprime, info2);

                            // compute color ci
                            vec3 ci;
                            if (uFinalGatheringVersion == 0) { // if ambient shading
                                if (gathering_intersect) { // if hits object, black
                                    ci = vec3(0.0);
                                }
                                else { // if hits infinite sphere, white
                                    ci = vec3(1.0);
                                }
                            }
                            else if (uFinalGatheringVersion == 1) { // if environment illumination/subsurface
                                if (gathering_intersect) { // if hits object, black
                                    ci = vec3(0.0);
                                }
                                else { // if hits infinite sphere, color of sphere
                                    ci = uSkyColor;
                                }
                            }
                            else if (uFinalGatheringVersion == 2) { // if color bleeding
                                if (gathering_intersect) { // if hits object, diffuse color of object
                                    if (info2.reflectType == 1) { // if another sphere
                                        ci = uSphere1Color;
                                    }
                                    else if (info2.reflectType == 2) { // if sphere 2
                                        ci = uSphere2Color;
                                    }
                                    else if (info2.reflectType == 0) { // if ground
                                        vec2 uv;
                                        uv.x = info2.u;
                                        uv.y = info2.v;
                                        ci = texture(uFloorTexture, uv).xyz;
                                    }
                                    else { // should never reach here :)
                                        continue;
                                    }
                                }
                                else { // if hits infinite sphere, color of sphere
                                    ci = uSkyColor;
                                }
                            }
                            else if (uFinalGatheringVersion == 3) { // if caustics
                                if (gathering_intersect) { // if hits object, refractive or specular color of object
                                    // TODO: this one kinda hard
                                    // go through the object if refractive and find color of next object
                                    // otherwise, use specular color
                                }
                                else { // if hits infinite sphere, color of sphere
                                    ci = uSkyColor;
                                }
                            }

                            
                            // update color of the pixel
                            wc = wc + (costheta * ci);
                            w = w + costheta;
                        }

                        c = wc / w;
                } else { // surrounding environment ("infinite sphere")
                    // vec3 pp;
                    // bool test = envSphere(pos, dir, SPHERE_POS4, 20.0, 0.00001, 1000.0, pp);
                    // vec2 uv = sphereMap(pp, SPHERE_POS4, 20.0);
                    // if (uFinalGatheringVersion == 0) { // white for ambient
                        // c = vec3(1, 1, 1); 
                    // }
                    // else { // baby blue for all other gatherings
                        c = uSkyColor;
                    // }
                    break;
                }
            }
            return c;
        }
        
        //============================================================================
        //Main
        //============================================================================
        
        void main() {
            vec2 m = uMouse / uResolution.y;
        
            randseed = random(gl_FragCoord.xy * 0.01);
        
            float camAngle = uCameraPosition * PI / 180.0;
            vec3 pos = vec3(10.0 * cos(camAngle), uCameraHeight, 10.0 * sin(camAngle));
            vec3 tar = vec3(0.0, 0.0, 0.0);
            mat3 cam = camera(pos, tar, vec3(0.0, 1.0, 0.0));
        
            vec3 c = vec3(0.0);
            const int SPP = 10;
            int sqrtSPP = int(sqrt(float(SPP)));
        
            vec3 lightPoints[SPP];
        
            for(int i = 1; i <= 5; i++) {
                Light light = light();
        
                //vec2 pixel = gl_FragCoord.xy + random2();
                vec2 pixel = gl_FragCoord.xy + random(gl_FragCoord.xy + float(i) * vec2(0.01));
                vec2 st = (2.0 * pixel - uResolution.xy) / uResolution.xy;
                vec3 rpos, rdir;
                ray(cam, pos, st, uFieldOfView, uResolution.x / uResolution.y, rpos, rdir);
        
                c += trace(rpos, rdir, light);
                if(uSamples == i)
                    break;
            }
            c /= float(uSamples < 5 ? uSamples : 5);
        
            c = pow(c, vec3(1.0 / 2.2));
        
            fragmentColor = vec4(c, 1.0);
        }
        `,
      });

      const props = {
        cameraPosition: 0.0,
        cameraHeight: 4.0,
        fieldOfView: 90.0,
        focus: 10.0,
        aperture: 0.0,
        skyColor: [54.0, 81.0, 94.0], // baby blue :)
        groundColor: [122.0, 122.0, 122.0], // grey
        sphere1color: [220.0, 100.0, 100.0], // 
        sphere2color: [100.0, 220.0, 100.0],
        metalColor: [255.0, 255.0, 255.0],
        fuzziness: 0.0,
        samples: 20,
        lightX:0.0,
        lightY:0.0,
        lightZ:0.0,
        ambientOcclusion: false,
        environmentIllumination: false,
        colorBleeding: false,
        caustics: false
      };

      const gui = new dat.GUI();
      const guiCamera = gui.addFolder('Camera');
      addToGui(guiCamera, props, 'cameraPosition', function(v) {
        glsl.setUniform('uCameraPosition', '1f', v);
      }, this, -360, 360);
      addToGui(guiCamera, props, 'cameraHeight', function(v) {
        glsl.setUniform('uCameraHeight', '1f', v);
      }, this, 0.0, 10.0);
      addToGui(guiCamera, props, 'fieldOfView', function(v) {
        glsl.setUniform('uFieldOfView', '1f', v);
      }, this, 0, 180);
      addToGui(guiCamera, props, 'focus', function(v) {
        glsl.setUniform('uFocus', '1f', v);
      }, this, 5, 25);
      addToGui(guiCamera, props, 'aperture', function(v) {
        glsl.setUniform('uAperture', '1f', v);
      }, this, 0.0, 1.0);
      const guiLight = gui.addFolder('Light');
      addToGui(guiLight, props, 'lightX', function(v) {
        glsl.setUniform('uLightX', '1f', v);
      }, this, -50, 50);
      addToGui(guiLight, props, 'lightY', function(v) {
        glsl.setUniform('uLightY', '1f', v);
      }, this, -50, 50);
      addToGui(guiLight, props, 'lightZ', function(v) {
        glsl.setUniform('uLightZ', '1f', v);
      }, this, -50, 50);

      // adding switches for project 9
      const guiIllumation = gui.addFolder('Image Based Illumination');
      addToGui(guiIllumation, props, 'ambientOcclusion', function(v) {
        if (v) {
            console.log('ambient occlusion');
            glsl.setUniform('uFinalGatheringVersion', '1i', 0);
        }
        else {
            glsl.setUniform('uFinalGatheringVersion', '1i', 4);
        }
      }, this);
      addToGui(guiIllumation, props, 'environmentIllumination', function(v) {
        if (v) {
            console.log('environment illumination');
            glsl.setUniform('uFinalGatheringVersion', '1i', 1);
        }
        else {
        glsl.setUniform('uFinalGatheringVersion', '1i', 4);
        }
      }, this);
    //   addToGui(guiIllumation, props, 'colorBleeding', function(v) {
    //     if (v) {
    //         console.log('color bleeding');
    //         glsl.setUniform('uFinalGatheringVersion', '1i', 2);
    //     }
    //     else {
    //         glsl.setUniform('uFinalGatheringVersion', '1i', 4);
    //     }
    //   }, this);
    //   addToGui(guiIllumation, props, 'caustics', function(v) {
    //     if (v) {
    //         console.log('caustics');
    //         glsl.setUniform('uFinalGatheringVersion', '1i', 3);
    //     }
    //     else {
    //         glsl.setUniform('uFinalGatheringVersion', '1i', 4);
    //     }
    //   }, this);

      const guiColors = gui.addFolder('Object Colors');
      // TODO: FIGURE OUT COLORS :DD
      addColorToGui(guiColors, props, 'skyColor', function(v) {
        glsl.setUniform('uSkyColor', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);
      addColorToGui(guiColors, props, 'groundColor', function(v) {
        glsl.setUniform('uGroundColor', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);
      addColorToGui(guiColors, props, 'sphere1color', function(v) {
        glsl.setUniform('uSphere1Color', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);
      addColorToGui(guiColors, props, 'sphere2color', function(v) {
        glsl.setUniform('uSphere2Color', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);

      addToGui(gui, props, 'samples', function(v) {
        glsl.setUniform('uSamples', '1i', v);
      }, this, 1, 100);

      glsl.setUniform('uCameraPosition', '1f', props.cameraPosition);
      glsl.setUniform('uFieldOfView', '1f', props.fieldOfView);
      glsl.setUniform('uCameraHeight', '1f', props.cameraHeight);
      glsl.setUniform('uFocus', '1f', props.focus);
      glsl.setUniform('uAperture', '1f', props.aperture);
      glsl.setUniform('uGroundColor', '3fv', [props.groundColor[0] / 255.0, props.groundColor[1] / 255.0, props.groundColor[2] / 255.0]);
      glsl.setUniform('uSkyColor', '3fv', [props.skyColor[0] / 255.0, props.skyColor[1] / 255.0, props.skyColor[2] / 255.0]);
      glsl.setUniform('uSphere1Color', '3fv', [props.sphere1color[0] / 255.0, props.sphere1color[1] / 255.0, props.sphere1color[2] / 255.0]);
      glsl.setUniform('uSphere2Color', '3fv', [props.sphere2color[0] / 255.0, props.sphere2color[1] / 255.0, props.sphere2color[2] / 255.0]);
      glsl.setUniform('uMetalColor', '3fv', [props.metalColor[0] / 255.0, props.metalColor[1] / 255.0, props.metalColor[2] / 255.0]);
      glsl.setUniform('uFuzziness', '1f', props.fuzziness);
      glsl.setUniform('uSamples', '1i', props.samples);
      glsl.setUniform('uFinalGatheringVersion', '1i', 4);
      glsl.setTexture('uRandomTexture', './textures/rgb_noise.bmp');
      glsl.setTexture('uFloorTexture', './textures/broken_wall_diff_2k.jpg');
      glsl.setTexture('uFloorNormal', './textures/broken_wall_nor_gl_2k.png');
      glsl.setTexture('uSphereEnvironment', './textures/solitude_night_4k.png');
      glsl.start();
    });
  </script>
</body>
</html>

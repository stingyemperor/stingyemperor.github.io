<!DOCTYPE html>
<html lang="en">
<head>
  <title>Image Based Illumination</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
  <script src="glsl.js"></script>
  <script>

    function addColorToGui(gui, props, name, func, scope) {
      const controller = gui.addColor(props, name);
      controller.onChange(func.bind(scope));
    }

    function addToGui(gui, props, name, func, scope, min, max, step) {
      const controller = gui.add(props, name, min, max, step);
      controller.onChange(func.bind(scope));
    }

    document.addEventListener('DOMContentLoaded', function() {

      const glsl = new GLSL({
        canvasId: 'canvas',
        fragmentShaderSource: `#version 300 es
        precision mediump float;
        
        //============================================================================
        //uniforms.
        //============================================================================
        
        uniform float uTime;
        uniform vec2 uResolution;
        uniform vec2 uMouse;
        uniform bool uMousePressed;
        
        uniform float uCameraPosition;
        uniform float uCameraHeight;
        uniform float uFieldOfView;
        uniform float uFocus;
        uniform float uAperture;
        uniform vec3 uSkyColor;
        uniform vec3 uSphere1Color;
        uniform vec3 uGroundColor;
        uniform vec3 uSphere2Color;
        uniform vec3 uMetalColor;
        uniform float uFuzziness;
        uniform int uSamples;
        uniform sampler2D uRandomTexture;
        uniform sampler2D uFloorTexture;
        uniform sampler2D uFloorNormal;
        uniform sampler2D uSphereEnvironment;
        uniform float uLightX;
        uniform float uLightY;
        uniform float uLightZ;
        uniform samplerCube uSkyBox;
        uniform mat4 uViewDirectionProjectionInverse;
        uniform int uFinalGatheringVersion; // 0 for ambient, 1 for env. ill., 2 for color bleeding, 3 for caustics
        
        in vec4 vPosition;
        out vec4 fragmentColor;
        
        #define PI 3.14159265359
        #define TWO_PI 6.28318530718

        #define NUM_OF_FACES 6
        #define NUM_OF_VERTICES 8

        //============================================================================
        //Structs
        //============================================================================        
        struct HitInfo {
            vec3 pos;
            vec3 normal;
            int reflectType;
            float u, v;
        };
        
        struct Light {
            vec3 position;
            vec3 direction;
            vec3 color;
            float intensity;
            vec3 uvec;
            vec3 vvec;
            int vsteps;
            int usteps;
            int samples;
        };
        
        struct Material {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            float shininess;
            float refractionCoeff;
            float refractionIndex;
        };
        
        struct Mesh {
            int numFaces;
            int numTriangles;
            int[NUM_OF_FACES] faceIndex;
            int[NUM_OF_VERTICES] vertIndex;
            vec3[NUM_OF_VERTICES] vertices;
            vec3[NUM_OF_FACES] normals;
            vec2[100] st;
        };
        //============================================================================
        //Randomness.
        //============================================================================
        
        float random(float x) {
            return fract(sin(x) * 4245.324);
        }
        
        float random(vec2 x) {
            return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        vec2 random2(vec2 x) {
            return fract(sin(vec2(dot(x, vec2(12.9898, 78.233)), dot(x, vec2(19.392, 59.434)))) * 43758.5453123);
        }
        
        float randseed = 0.423;
        
        float random() {
            randseed += 1.0;
            return random(randseed);
        }
        
        int randIndex() {
        
            return int(gl_FragCoord.x * fract(sin(dot(gl_FragCoord.xy * 0.01, vec2(19.342, 54.342)) * 3244.4234)) * 256.0 * 256.0);
        }
        
        vec2 randompos() {
            int randomindex = randIndex();
            int h = randomindex / 256;
            int w = randomindex - h * 256;
            return vec2(float(w) / 256.0, float(h) / 256.0);
        }
        vec3 random3() {
            int randomindex = randIndex();
            randomindex += 1;
            return texture(uRandomTexture, randompos()).xyz;
        }
        vec2 random2() {
            return random3().xy;
        }
        float random4() {
            return random3().x;
        }
        
        vec3 random_in_unit_sphere() {
            vec3 v;
            for(int i = 0; i < 100; i++) {
                randseed += 0.01;
                float rx = random(randseed);
                randseed += 0.01;
                float ry = random(randseed);
                randseed += 0.01;
                float rz = random(randseed);
                v = vec3(rx, ry, rz) * 2.0 - 1.0;
                if(length(v) <= 1.0)
                    break;
            }
            return v;
        }
        
        vec2 random_on_unit_disk() {
            vec2 v;
            for(int i = 0; i < 100; i++) {
                randseed += 0.01;
                float rx = random(randseed);
                randseed += 0.01;
                float ry = random(randseed);
                v = vec2(rx, ry) * 2.0 - 1.0;
                if(length(v) <= 1.0)
                    break;
            }
            return v;
        }
        
        vec3 randomCosineHemisphere() {
            float r1 = random4();
            float r2 = random4();
            float z = sqrt(1.0 - r2);
            float phi = TWO_PI * r1;
            float x = cos(phi) * sqrt(r2);
            float y = sin(phi) * sqrt(r2);
            return vec3(x, y, z);
        }

        // project 9: calculate rotation of vector given theta
        // uses rodrigues' rotation formula
        // theta is in radians
        mat3 calculateRotationMatrix(float _theta, vec3 _rotdir) {
            // rodrigues' rotation formula
            // float dirx = _rotdir.x;
            // float diry = _rotdir.y;
            // float dirz = _rotdir.z;
            float costheta = cos(_theta);
            float sintheta = sin(_theta);
            vec3 row1 = vec3(costheta + (_rotdir.x * _rotdir.x) * (1.0 - costheta), _rotdir.x * _rotdir.y * (1.0 - costheta) - _rotdir.z * sintheta, _rotdir.y * sintheta + _rotdir.x * _rotdir.z * (1.0 - costheta));
            vec3 row2 = vec3(_rotdir.z * sintheta + _rotdir.x * _rotdir.y * (1.0-costheta), costheta+_rotdir.y*_rotdir.y*(1.0-costheta), -_rotdir.x*sintheta+_rotdir.y*_rotdir.z*(1.0-costheta));
            vec3 row3 = vec3(-_rotdir.y*sintheta+_rotdir.x*_rotdir.z*(1.0-costheta),_rotdir.x*sintheta+_rotdir.y*_rotdir.z*(1.0-costheta),costheta+_rotdir.z*_rotdir.z*(1.0-costheta));
            return mat3(row1, row2, row3);
        }
        
        //============================================================================
        //Camera
        //============================================================================
        
        mat3 camera(in vec3 pos, in vec3 tar, in vec3 up) {
            vec3 cz = normalize(tar - pos);
            vec3 cx = normalize(cross(cz, normalize(up)));
            vec3 cy = normalize(cross(cx, cz));
            return mat3(cx, cy, cz);
        }
        
        //============================================================================
        //Ray
        //============================================================================
        
        void ray(in mat3 cam, in vec3 origin, in vec2 uv, in float vfov, in float aspect, inout vec3 rpos, inout vec3 rdir) {
            float theta = vfov * PI / 180.0;
            float h = tan(theta / 2.0);
            float w = h * aspect;
            vec3 offset = cam * vec3(random_on_unit_disk(), 0.0) * uAperture;
            rpos = origin + offset;
            rdir = normalize(origin + cam * uFocus * vec3(w * uv.x, h * uv.y, 1.0) - rpos);
        }
        
        //============================================================================
        //Plane
        //============================================================================
        vec2 planeMap(vec3 point) {
            vec3 normal = vec3(0.0, 1.0, 0.0);
            vec3 u = normalize(vec3(normal.y, -normal.x, 0));
            vec3 v = cross(normal, u);
            float hu = dot(u, point);
            float hv = dot(v, point);
            return vec2(hu, hv);
        }
        
        bool plane(in vec3 pos, in vec3 dir, in float y, in int reflectType, in float tmin, inout float tmax, inout HitInfo info) {
            if(dir.y == 0.0)
                return false;
            float tt = (y - pos.y) / dir.y;
            if(tt > tmin && tt < tmax) {
                info.pos = pos + tt * dir;
        
                vec2 uv = planeMap(info.pos);
                info.normal = vec3(0.0, 1.0, 0.0);
                info.reflectType = reflectType;
                info.u = uv.x;
                info.v = uv.y;
                return true;
            }
            return false;
        }
        
        bool plane(in vec3 pos, in vec3 dir, in float y, in float tmin, in float tmax) {
            if(dir.y == 0.0)
                return false;
            float tt = (y - pos.y) / dir.y;
            if(tt > tmin && tt < tmax) {
                return true;
            }
            return false;
        }
        
        bool IntersectPlane(float A, float B, float C, float D, in int reflectType, vec3 pos, vec3 dir, in float tmin, inout float tmax, inout HitInfo info) {
            vec3 N = vec3(A, B, C);
            float NRd = dot(N, dir);
            float NRo = dot(N, pos);
            float t0 = (-D - NRo) / NRd;
            if(t0 < tmin || t0 > tmax)
                return false;
        
            // We have a hit -- output results.
            tmax = t0;
            info.pos = pos + t0 * dir;
            vec2 uv = planeMap(info.pos);
            // vec3 tempN = texture(uFloorNormal, uv).xyz;
            // info.normal = tempN;
            info.normal = vec3(0.0, 1.0, 0.0);
            info.reflectType = reflectType;
            info.u = uv.x;
            info.v = uv.y;
            return true;
        }
        
        bool IntersectPlane(float A, float B, float C, float D, in int reflectType, vec3 pos, vec3 dir, in float tmin, in float tmax) {
            vec3 N = vec3(A, B, C);
            float NRd = dot(N, dir);
            float NRo = dot(N, pos);
            float t0 = (-D - NRo) / NRd;
            if(t0 < tmin || t0 > tmax)
                return false;
            return true;
        }
        
        bool rectZX(in float z1, in float x1, in float z2, in float x2, in float y, in float tmin, inout float tmax, vec3 pos, vec3 dir, in int reflectType, inout HitInfo hitInfo) {
            float t = (y - pos.y) / dir.y;
            vec3 p = pos + t * dir;
            if(t < tmin || t > tmax || p.z < z1 || p.z > z2 || p.x < x1 || p.x > x2)
                return false;
            tmax = t;
            vec2 uv = planeMap(hitInfo.pos);
            // vec3 tempN = texture(uFloorNormal, uv).xyz;
            // hitInfo.normal = tempN;
            hitInfo.pos = p;
            hitInfo.u = uv.x;
            hitInfo.v = uv.y;
            hitInfo.normal = vec3(0.0, 1.0, 0.0);
            hitInfo.reflectType = reflectType;
            return true;
        }
        
        bool rectZX(in float z1, in float x1, in float z2, in float x2, in float y, in float tmin, inout float tmax, vec3 pos, vec3 dir) {
            float t = (y - pos.y) / dir.y;
            vec3 p = pos + t * dir;
            if(t < tmin || t > tmax || p.z < z1 || p.z > z2 || p.x < x1 || p.x > x2)
                return false;
            tmax = t;
            return true;
        }
        
        //============================================================================
        //Sphere
        //============================================================================
        
        bool sphere(in vec3 pos, in vec3 dir, in vec3 center, in float radius, in int reflectType, in float tmin, inout float tmax, inout HitInfo info) {
            vec3 oc = pos - center;
            float a = dot(dir, dir);
            float b = dot(oc, dir);
            float c = dot(oc, oc) - radius * radius;
            float dis = b * b - a * c;
        
            if(dis < 0.0)
                return false;
        
            float tt = (-b - sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                tmax = tt;
                info.pos = pos + tt * dir;
                info.normal = normalize(info.pos - center);
                info.reflectType = reflectType;
                return true;
            }
            tt = (-b + sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                tmax = tt;
                info.pos = pos + tt * dir;
                info.normal = normalize(info.pos - center);
                info.reflectType = reflectType;
                return true;
            }
        
            return false;
        }
        
        bool sphere(in vec3 pos, in vec3 dir, in vec3 center, in float radius, in float tmin, in float tmax) {
            vec3 oc = pos - center;
            float a = dot(dir, dir);
            float b = dot(oc, dir);
            float c = dot(oc, oc) - radius * radius;
            float dis = b * b - a * c;
        
            if(dis < 0.0)
                return false;
        
            float tt = (-b - sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
        
                return true;
            }
            tt = (-b + sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
        
                return true;
            }
        
            return false;
        }
        
        bool envSphere(in vec3 pos, in vec3 dir, in vec3 center, in float radius, in float tmin, in float tmax, out vec3 env) {
            vec3 oc = pos - center;
            float a = dot(dir, dir);
            float b = dot(oc, dir);
            float c = dot(oc, oc) - radius * radius;
            float dis = b * b - a * c;
        
            if(dis < 0.0)
                return false;
        
            float tt = (-b - sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                env = pos + tt * dir;
                return true;
            }
            tt = (-b + sqrt(dis)) / a;
            if(tt > tmin && tt < tmax) {
                env = pos + tt * dir;
                return true;
            }
        
            return false;
        }
        
        vec2 sphereMap(vec3 point, vec3 center, float radius) {
            float theta = atan(-(point.z - center.z), point.x - center.x);
            float u = (theta + PI) / TWO_PI;
            float phi = acos(-(point.y - center.y) / radius);
            float v = phi / PI;
        
            return vec2(u, v);
        }
        
        const float POS_RADIUS = 3.0;
        const float POS_RADIUS2 = 4.0;
        const vec3 SPHERE_POS1 = vec3(POS_RADIUS * cos(0.0), 10.0, POS_RADIUS * sin(0.0));
        const vec3 SPHERE_POS2 = vec3(POS_RADIUS2 * -cos(TWO_PI / 3.0), 3.0, POS_RADIUS2 * sin(TWO_PI / 3.0));
        const vec3 SPHERE_POS3 = vec3(POS_RADIUS * cos(TWO_PI / 3.0 * 2.0), 3.0, POS_RADIUS * sin(TWO_PI / 3.0 * 2.0));
        const vec3 SPHERE_POS4 = vec3(0.0, 0.0, 0.0);
        const float SPHERE_RADIUS = 3.0;
        const float SPHERE_RADIUS2 = 3.0;
        
        //============================================================================
        //Triangle
        //============================================================================
        
        bool triangle(in vec3 pos, in vec3 dir, vec3 v0, vec3 v1, vec3 v2, out HitInfo info, in int reflectType) {
        
            float epsilon = 0.001;
            vec3 e1 = v1 - v0;
            vec3 e2 = v2 - v0;
            vec3 h = cross(dir, e2);
        
            float a = dot(e1, h);
        
            if(a < epsilon && a > epsilon) {
                return false;
            }
        
            float f = 1.0 / a;
            vec3 s = pos - v0;
        
            float u = f * dot(s, h);
        
            if(u < 0.0 || u > 1.0) {
                return false;
            }
        
            vec3 q = cross(s, e1);
            float v = f * dot(dir, q);
        
            if(v < 0.0 || u + v > 1.0) {
                return false;
            }
        
            float t = f * dot(e2, q);
        
            info.pos = pos + t * dir;
            info.normal = cross(e1, e2);
            info.reflectType = reflectType;
        
            if(t > epsilon) {
                return true;
            }
        
            return true;
        }
        
        bool triangle(in vec3 pos, in vec3 dir, vec3 v0, vec3 v1, vec3 v2) {
        
            float epsilon = 0.001;
            vec3 e1 = v1 - v0;
            vec3 e2 = v2 - v0;
            vec3 h = cross(dir, e2);
        
            float a = dot(e1, h);
        
            if(a < epsilon && a > epsilon) {
                return false;
            }
        
            float f = 1.0 / a;
            vec3 s = pos - v0;
        
            float u = f * dot(s, h);
        
            if(u < 0.0 || u > 1.0) {
                return false;
            }
        
            vec3 q = cross(s, e1);
            float v = f * dot(dir, q);
        
            if(v < 0.0 || u + v > 1.0) {
                return false;
            }
        
            float t = f * dot(e2, q);
        
            if(t > epsilon) {
                return true;
            }
        
            return true;
        }
        
        int numTriangles(inout Mesh mesh, out int k, out int maxVertIndex, out int[100] triangleIndex, out vec2[100] texCoordinate) {
        
            k = 0;
            maxVertIndex = 0;
        
            for(int i = 0; i < mesh.numFaces; i++) {
                mesh.numTriangles += mesh.faceIndex[i] - 2;
                for(int j = 0; j < mesh.faceIndex[i]; j++) {
                    if(mesh.vertIndex[k + j] > maxVertIndex) {
                        maxVertIndex = mesh.vertIndex[k + j];
                    }
        
                    k += mesh.faceIndex[i];
                }
            }
        
            maxVertIndex += 1;
        
            vec3[100] P;
        
            for(int i = 0; i < maxVertIndex; i++) {
                P[i] = mesh.vertices[i];
            }
        
            int l = 0;
        
            vec3[100] N;
            for(int i = 0, k = 0; i < mesh.numFaces; i++) {
                for(int j = 0; j < mesh.faceIndex[i] - 2; j++) {
                    triangleIndex[l] = mesh.vertIndex[k];
                    triangleIndex[l + 1] = mesh.vertIndex[k + j + 1];
                    triangleIndex[l + 2] = mesh.vertIndex[k + j + 2];
                    texCoordinate[l] = mesh.st[k];
                    texCoordinate[l + 1] = mesh.st[k + j + 1];
                    texCoordinate[l + 2] = mesh.st[k + j + 2];
        
                    l += 3;
                }
                k += mesh.faceIndex[i];
            }
        
            return 0;
        }

        
        //============================================================================
        //Intersection
        //============================================================================
        // for objects
        bool intersect(in vec3 pos, in vec3 dir, inout HitInfo info, Light light) {
            float tmin = 0.00001;
            float tmax = 10000.0;
            bool hit = false;
            hit = sphere(pos, dir, SPHERE_POS3, SPHERE_RADIUS, 1, tmin, tmax, info) || hit;
            hit = sphere(pos, dir, SPHERE_POS2, SPHERE_RADIUS2, 2, tmin, tmax, info) || hit;
            hit = IntersectPlane(0.0, 1.0, 0.0, 0.0, 0, pos, dir, tmin, tmax, info) || hit;
        
            vec3 v0 = vec3(-5.0, 5.0, 5.0);
            vec3 v1 = vec3(-5.0, -5.0, 5.0);
            vec3 v2 = vec3(5.0, -5.0, 5.0);
            return hit;
        }

        // for final gathering (no light parameter)
        bool intersect(in vec3 pos, in vec3 dir, inout HitInfo info) {
            float tmin = 0.00001;
            float tmax = 10000.0;
            bool hit = false;
            hit = sphere(pos, dir, SPHERE_POS3, SPHERE_RADIUS, 1, tmin, tmax, info) || hit;
            hit = sphere(pos, dir, SPHERE_POS2, SPHERE_RADIUS2, 2, tmin, tmax, info) || hit;
        
            vec3 v0 = vec3(-5.0, 5.0, 5.0);
            vec3 v1 = vec3(-5.0, -5.0, 5.0);
            vec3 v2 = vec3(5.0, -5.0, 5.0);
            return hit;
        }
        
        // for shadows
        bool intersect(in vec3 pos, in vec3 dir, float tMax) {
            float tmin = 0.00001;
            bool hit = false;
            hit = sphere(pos, dir, SPHERE_POS2, SPHERE_RADIUS, tmin, tMax) || hit;
            hit = sphere(pos, dir, SPHERE_POS3, SPHERE_RADIUS2, tmin, tMax) || hit;
            hit = IntersectPlane(0.0, 1.0, 0.0, 0.0, 0, pos, dir, tmin, tMax) || hit;
        
            vec3 v0 = vec3(-5.0, 5.0, 5.0);
            vec3 v1 = vec3(-5.0, -5.0, 5.0);
            vec3 v2 = vec3(5.0, -5.0, 5.0);
            return hit;
        }
        
        //============================================================================
        //Refraction
        //============================================================================
        
        float schlick(float cosine, float ref) {
            float r0 = (1.0 - ref) / (1.0 + ref);
            r0 = r0 * r0;
            return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
        }
        
        //============================================================================
        //Lighting
        //============================================================================
        
        Light light() {
        
            Light light;
            light.position = vec3(6.0, 8.0, 8.0) + vec3(uLightX, uLightY, uLightZ);
            light.color = vec3(1.0, 1.0, 0.6);
            light.intensity = 1.0;
            light.usteps = 6;
            light.vsteps = 6;
            light.uvec = light.position + vec3(0, 0, 4);
            light.vvec = light.position + vec3(0, 4, 0);
            light.samples = light.usteps * light.vsteps;
        
            return light;
        }
        
        Light fakeSphericalLight() {
            Light light;
        
            return light;
        }
        
                                //Cells are defined by u and v
        
        vec3 pointOnLight(Light light, float u, float v) {
        
            return light.position + light.uvec * (u + random4()) + light.vvec * (v + random());
        
        }
        
        bool pointInShadow(vec3 lightPoint, HitInfo info) {
        
            vec3 shadowRayOrigin = info.pos;
            vec3 shadowRayDirection = normalize(lightPoint - info.pos);
            float dist = length(lightPoint - info.pos);
            if(intersect(shadowRayOrigin, shadowRayDirection, dist)) {
                return true;
            } else {
                return false;
            }
        
            return true;
        }
        
        float intensityAt(Light light, HitInfo info, out bool shadow, vec3 pos, Material material, out vec3 color) {
            float total = 0.0;
            shadow = false;
            vec3 sum = vec3(0.0);
            for(int v = 0; v < light.vsteps; v++) {
                for(int u = 0; u < light.usteps; u++) {
        
                    vec3 lightPosition = pointOnLight(light, float(u), float(v));
        
                    vec3 L = normalize(lightPosition - info.pos);
                    vec3 N = normalize(info.normal);
                    vec3 V = normalize(pos - info.pos);
        
                    vec3 R = reflect(-L, N);
                    float NdotL = max(dot(N, L), 0.0);
                    float RdotV = max(dot(R, V), 0.0);
                    float RfotVpown = (RdotV == 0.0) ? 0.0 : pow(RdotV, material.shininess);
        
                    sum = sum + NdotL * material.diffuse;
                    sum = sum + RfotVpown * material.specular;
        
                    // comment out next line for no shadows
                    // if(!pointInShadow(lightPosition, info)) {
                    total = total + 1.0;
                    //     shadow = true;
                    // }
                }
            }
        
            // color = (material.ambient + (sum / float(light.samples)) * light.intensity)*light.color;
            // version without light intensity
            color = (material.ambient + (sum / float(light.samples)))*light.color;

            return total / float(light.samples);
        }
        
        //============================================================================
        //Materials
        //============================================================================
        Material plane(vec3 diffuse) {
            Material plane;
            plane.diffuse = diffuse;
            plane.ambient = 0.1 * diffuse;
            plane.specular = 3.0 * diffuse;
            plane.shininess = 64.0;
        
            return plane;
        }
        
        Material sphere(vec3 diffuse) {
            Material sphere;
        
            sphere.diffuse = diffuse;
            sphere.ambient = 0.2 * sphere.diffuse;
            sphere.specular = 2.0 * sphere.diffuse;
            sphere.shininess = 64.0;
            return sphere;
        }
        
        Material mirror() {
            Material mirror;
            mirror.diffuse = vec3(0.5, 0.5, 0.5);
            mirror.ambient = 0.2 * mirror.diffuse;
            mirror.specular = 2.0 * mirror.specular;
            mirror.shininess = 64.0;
            return mirror;
        }
        
        //============================================================================
        //Ray Tracer
        //============================================================================
        vec3 trace(in vec3 pos, in vec3 dir, in Light light) {
        
            // for now, hardcode geodesic sphere
            // float num_geodesic = 66.0;
            // vec3 geodesic[66];
            // geodesic[0] = vec3(-0.430169, -0.792515, 0.43229);
            // geodesic[1] = vec3(0.435218, 0.433667, 0.788998);
            // geodesic[2] = vec3(-0.78803, 0.433097, 0.437534);
            // geodesic[3] = vec3(0.436176, -0.42123, 0.795183);
            // geodesic[4] = vec3(-0.432018, -0.78769, -0.439209);
            // geodesic[5] = vec3(0.00830602, 0.999936, -0.00764532);
            // geodesic[6] = vec3(0.999681, -0.024016, -0.00782368);
            // geodesic[7] = vec3(-0.0483102, -0.030691, -0.998361);
            // geodesic[8] = vec3(-0.998271, -0.0318236, 0.0494162);
            // geodesic[9] = vec3(0.00771543, -0.039023, 0.999209);
            // geodesic[10] = vec3(0.000736635, -1, -0.000162692);
            // geodesic[11] = vec3(0.00705369, -0.700696, 0.713425);
            // geodesic[12] = vec3(-0.702487, 0.00902333, 0.711639);
            // geodesic[13] = vec3(0.717257, 0.0104498, 0.696731);
            // geodesic[14] = vec3(0.698747, 0.715279, -0.0113935);
            // geodesic[15] = vec3(-0.0102122, 0.713327, -0.700757);
            // geodesic[16] = vec3(-0.692692, 0.721223, 0.00383561);
            // geodesic[17] = vec3(0.71969, -0.694218, -0.0103505);
            // geodesic[18] = vec3(-0.00498393, -0.693576, -0.720366);
            // geodesic[19] = vec3(-0.713566, -0.700585, -0.00183561);
            // geodesic[20] = vec3(0.00517374, 0.722551, 0.691298);
            // geodesic[21] = vec3(0.700056, 0.00526936, -0.714068);
            // geodesic[22] = vec3(-0.710371, 0.00720582, -0.70379);
            // geodesic[23] = vec3(0.00294034, -0.954234, 0.299047);
            // geodesic[24] = vec3(0.00793723, -0.311896, 0.950083);
            // geodesic[25] = vec3(-0.287223, -0.0191003, 0.957673);
            // geodesic[26] = vec3(-0.945698, -0.0136581, 0.324759);
            // geodesic[27] = vec3(-0.951183, -0.307002, 0.0316403);
            // geodesic[28] = vec3(-0.297761, -0.954632, -0.00409671);
            // geodesic[29] = vec3(0.302119, -0.0191557, 0.953078);
            // geodesic[30] = vec3(0.959572, -0.0081825, 0.281345);
            // geodesic[31] = vec3(0.959399, 0.281908, -0.00902644);
            // geodesic[32] = vec3(0.289767, 0.957057, -0.00880356);
            // geodesic[33] = vec3(0.00736271, 0.961684, 0.274061);
            // geodesic[34] = vec3(0.0069995, 0.275826, 0.961182);
            // geodesic[35] = vec3(0.95471, -0.0103986, -0.297356);
            // geodesic[36] = vec3(0.258579, -0.0153934, -0.965868);
            // geodesic[37] = vec3(-0.035943, 0.276891, -0.960229);
            // geodesic[38] = vec3(0.00567149, 0.957149, -0.289539);
            // geodesic[39] = vec3(-0.319872, -0.0139508, -0.947358);
            // geodesic[40] = vec3(-0.964817, -0.0151712, -0.262484);
            // geodesic[41] = vec3(-0.959399, 0.279903, 0.0347532);
            // geodesic[42] = vec3(-0.274092, 0.961676, -0.00728487);
            // geodesic[43] = vec3(0.302078, -0.953277, -0.00351599);
            // geodesic[44] = vec3(0.954783, -0.297168, -0.00903092);
            // geodesic[45] = vec3(0.0022908, -0.953326, -0.301934);
            // geodesic[46] = vec3(-0.0330523, -0.301223, -0.952981);
            // geodesic[47] = vec3(0.423962, 0.809344, 0.40647);
            // geodesic[48] = vec3(0.417682, 0.804155, -0.422938);
            // geodesic[49] = vec3(-0.412413, 0.807306, -0.422105);
            // geodesic[50] = vec3(-0.411201, 0.812612, 0.413007);
            // geodesic[51] = vec3(0.80027, 0.434566, 0.413183);
            // geodesic[52] = vec3(0.792962, 0.43101, -0.430629);
            // geodesic[53] = vec3(0.808664, -0.414763, 0.417174);
            // geodesic[54] = vec3(0.800117, -0.414532, -0.433563);
            // geodesic[55] = vec3(0.411277, 0.431923, -0.802679);
            // geodesic[56] = vec3(-0.43401, 0.428809, -0.792312);
            // geodesic[57] = vec3(0.415414, -0.418216, -0.807791);
            // geodesic[58] = vec3(-0.434974, -0.414542, -0.799345);
            // geodesic[59] = vec3(-0.795826, -0.418923, 0.437224);
            // geodesic[60] = vec3(-0.796587, 0.436563, -0.418165);
            // geodesic[61] = vec3(-0.802351, -0.422856, -0.42122);
            // geodesic[62] = vec3(-0.421963, -0.423222, 0.801767);
            // geodesic[63] = vec3(-0.422368, 0.43499, 0.795229);
            // geodesic[64] = vec3(0.43949, -0.788954, 0.429417);
            // geodesic[65] = vec3(0.436415, -0.784972, -0.439728);

            float num_geodesic = 12.0;
            vec3 geodesic[12];
            geodesic[0] = vec3(0.525731, 0, 0.850651);
            geodesic[1] = vec3(0, 0.850651, 0.525731);
            geodesic[2] = vec3(-0.525731, 0, 0.850651);
            geodesic[3] = vec3(0, -0.850651, 0.525731);
            geodesic[4] = vec3(0.525731, 0, -0.850651);
            geodesic[5] = vec3(0, -0.850651, -0.525731);
            geodesic[6] = vec3(-0.525731, 0, -0.850651);
            geodesic[7] = vec3(0, 0.850651, -0.525731);
            geodesic[8] = vec3(0.850651, -0.525731, 0);
            geodesic[9] = vec3(0.850651, 0.525731, 0);
            geodesic[10] = vec3(-0.850651, 0.525731, 0);
            geodesic[11] = vec3(-0.850651, -0.525731, 0);

            HitInfo info;
            vec3 c = vec3(1.0);
        
            for(int i = 0; i < 1; i++) { // why 3 times? changed to 1 time
                if(intersect(pos, dir, info, light)) {
                    bool shadow = false;
                    vec3 L = normalize(light.position - info.pos);
                    vec3 N = normalize(info.normal);
                    vec3 V = normalize(pos - info.pos);
                    vec3 shadowRayOrigin = info.pos;
        
                    vec3 shadowRayDirection = L;
                    float dist = length(light.position - info.pos);
        
                    if(info.reflectType == 0) { // ground
                        vec2 uv;
                        uv.x = info.u;
                        uv.y = info.v;
                        if (uFinalGatheringVersion == 4) { // default
                            Material plane = plane(uGroundColor);
                            float intense = intensityAt(light, info, shadow, pos, plane, c);
                            c = c * intense;
                            continue;
                        }
                        else {
                            c = uGroundColor;
                        }
                    } 
                    // ONLY ONE USED FOR PROJECT 9
                    else if (info.reflectType == 1) { // if sphere 1, apply its color
                        if (uFinalGatheringVersion == 4) { // default
                            Material sphere = sphere(uSphere1Color);
                            float intense = intensityAt(light, info, shadow, pos, sphere, c);
                            c = c * intense;
                            continue;
                        }
                        else {
                            c = uSphere1Color;
                        }
                    }
                    else if (info.reflectType == 2) { // if sphere 2, apply its color
                        if (uFinalGatheringVersion == 4) { // default
                            Material sphere = sphere(uSphere2Color);
                            float intense = intensityAt(light, info, shadow, pos, sphere, c);
                            c = c * intense;
                            continue;
                        }
                        else {
                            c = uSphere2Color;
                        }
                    }
                    else { // should never happen...
                        c = vec3(0.0);
                    }

                    // if (uFinalGatheringVersion == 4) { // default
                    //     continue;
                    // }

                    // based on slides from final gathering
                    // iterate through different directions
                    HitInfo info2;
                    vec3 wc = c * num_geodesic;
                    float w = num_geodesic;
                    // calculate rot matrix of random angle about the normal
                    // pseudo-random based on seed of location! (random returns between 0 and 1)
                    float theta = random(info.pos.xy) * 2.0 * PI;
                    mat3 rotmatrix = calculateRotationMatrix(theta, N);
                    vec3 rotated_geo; // for use later
                    for (int i = 0; i < int(num_geodesic); ++i) {
                        // calculate rotation of geodesic (could go in function but probs too much memory usage tbh)
                        rotated_geo = geodesic[i] * rotmatrix;

                        // Nh denote unit shading normal (N?)
                        vec3 nplusr = N + rotated_geo;
                        vec3 nhprime = (nplusr)/length(nplusr);

                        // compute weight of ray
                        float costheta = dot(N, nhprime);

                        // if ray goes into the sphere, skip
                        if (costheta < 0.0) continue;
                    
                        // shoot ray and look for hit from info.pos in direction of nhprime
                        bool gathering_intersect = intersect(info.pos, nhprime, info2);

                        // compute color ci
                        vec3 ci;
                        if (uFinalGatheringVersion == 0) { // if ambient shading
                            if (gathering_intersect) { // if hits object, black
                                ci = vec3(0.0, 0.0, 0.0);
                            }
                            else { // if hits infinite sphere, white
                                ci = vec3(1.0, 1.0, 1.0);
                            }
                        }
                        else if (uFinalGatheringVersion == 1) { // if environment illumination/subsurface
                            if (gathering_intersect) { // if hits object, black
                                ci = vec3(0.0);
                            }
                            else { // if hits infinite sphere, color of sphere
                                ci = uSkyColor;
                            }
                        }
                        else if (uFinalGatheringVersion == 2) { // if color bleeding
                            if (gathering_intersect) { // if hits object, diffuse color of object
                                if (info2.reflectType == 1) { // if another sphere
                                    ci = uSphere1Color;
                                }
                                else if (info2.reflectType == 2) { // if sphere 2
                                    ci = uSphere2Color;
                                }
                                else if (info2.reflectType == 0) { // if ground
                                    ci = uGroundColor;
                                }
                                else { // should never reach here :)
                                    continue;
                                }
                            }
                            else { // if hits infinite sphere, color of sphere
                                ci = uSkyColor;
                            }
                        }
                        // else if (uFinalGatheringVersion == 3) { // if caustics
                        //     if (gathering_intersect) { // if hits object, refractive or specular color of object
                        //         // TODO: this one kinda hard
                        //         // go through the object if refractive and find color of next object
                        //         // otherwise, use specular color
                        //         // we will have refractive and specular modes ig
                        //         // this one is refractive
                        //         vec3 n;
                        //         float eta, cosine;
                        //         float prob = 0.0;
                        //         float indexOfRefraction = 1.3435; // user can change (this one is water)
                        //         if (dot(dir, info.normal) < 0.0) {
                        //             n = info.normal;
                        //             eta = 1.0/indexOfRefraction;
                        //             cosine = -dot(dir, info.normal) / length(dir);
                        //         } else {
                        //             n = -info.normal;
                        //             eta = indexOfRefraction;
                        //             cosine = indexOfRefraction * dot(dir, info.normal) / length(dir);
                        //         }
                        //         vec3 r = refract(normalize(dir), normalize(n), eta);
                        //         bool isRefracted = r.x!=0.0|| r.y!=0.0 ||r.z!=0.0;
                        //         if(isRefracted){
                        //             prob = schlick(cosine, uIndexOfRefraction);
                        //         }
                        //         if (random() < prob) {
                        //             dir = normalize(reflect(dir, n));
                        //         }
                        //     }
                        //     else { // if hits infinite sphere, color of sphere
                        //         ci = uSkyColor;
                        //     }
                        // }

                        
                        // update color of the pixel
                        wc = wc + (costheta * ci);
                        w = w + costheta;
                    }
                    c = wc / w;
                    Material sph = sphere(c);
                    float intense = intensityAt(light, info, shadow, pos, sph, c);
                    // c = c * intense;
                    

                } else { // surrounding environment ("infinite sphere")
                    // vec3 pp;
                    // bool test = envSphere(pos, dir, SPHERE_POS4, 20.0, 0.00001, 1000.0, pp);
                    // vec2 uv = sphereMap(pp, SPHERE_POS4, 20.0);
                    // if (uFinalGatheringVersion == 0) { // white for ambient
                        // c = vec3(1, 1, 1); 
                    // }
                    // else { // baby blue for all other gatherings
                        c = uSkyColor;
                    // }
                    break;
                }
            }
            return c;
        }
        
        //============================================================================
        //Main
        //============================================================================
        
        void main() {
            vec2 m = uMouse / uResolution.y;
        
            randseed = random(gl_FragCoord.xy * 0.01);
        
            float camAngle = uCameraPosition * PI / 180.0;
            vec3 pos = vec3(10.0 * cos(camAngle), uCameraHeight, 10.0 * sin(camAngle));
            vec3 tar = vec3(0.0, 0.0, 0.0);
            mat3 cam = camera(pos, tar, vec3(0.0, 1.0, 0.0));
        
            vec3 c = vec3(0.0);
            const int SPP = 10;
            int sqrtSPP = int(sqrt(float(SPP)));
        
            vec3 lightPoints[SPP];
        
            for(int i = 1; i <= 5; i++) {
                Light light = light();
        
                //vec2 pixel = gl_FragCoord.xy + random2();
                vec2 pixel = gl_FragCoord.xy + random(gl_FragCoord.xy + float(i) * vec2(0.01));
                vec2 st = (2.0 * pixel - uResolution.xy) / uResolution.xy;
                vec3 rpos, rdir;
                ray(cam, pos, st, uFieldOfView, uResolution.x / uResolution.y, rpos, rdir);
        
                c += trace(rpos, rdir, light);
                if(uSamples == i)
                    break;
            }
            c /= float(uSamples < 5 ? uSamples : 5);
        
            c = pow(c, vec3(1.0 / 2.2));
        
            fragmentColor = vec4(c, 1.0);
        }
        `,
      });

      const props = {
        cameraPosition: 0.0,
        cameraHeight: 5.2, // just above the horizon
        fieldOfView: 90.0,
        focus: 10.0,
        aperture: 0.0,
        skyColor: [129.0, 136.0, 255.0], // 0.5 alpha dark blue
        groundColor: [255.0, 1.0, 195.0], // purple-pink neonish
        sphere1color: [225.0, 255.0, 0.0], // yellow
        sphere2color: [0.0, 240.0, 255.0], // baby blue
        metalColor: [255.0, 255.0, 255.0],
        fuzziness: 0.0,
        samples: 20,
        lightX:0.0,
        lightY:0.0,
        lightZ:0.0,
        ambientOcclusion: false,
        environmentIllumination: false,
        colorBleeding: false,
        caustics: false
      };

      const gui = new dat.GUI();
      const guiCamera = gui.addFolder('Camera');
      addToGui(guiCamera, props, 'cameraPosition', function(v) {
        glsl.setUniform('uCameraPosition', '1f', v);
      }, this, -360, 360);
      addToGui(guiCamera, props, 'cameraHeight', function(v) {
        glsl.setUniform('uCameraHeight', '1f', v);
      }, this, 0.0, 10.0);
      addToGui(guiCamera, props, 'fieldOfView', function(v) {
        glsl.setUniform('uFieldOfView', '1f', v);
      }, this, 0, 180);
      addToGui(guiCamera, props, 'focus', function(v) {
        glsl.setUniform('uFocus', '1f', v);
      }, this, 5, 25);
      addToGui(guiCamera, props, 'aperture', function(v) {
        glsl.setUniform('uAperture', '1f', v);
      }, this, 0.0, 1.0);
      const guiLight = gui.addFolder('Light');
      addToGui(guiLight, props, 'lightX', function(v) {
        glsl.setUniform('uLightX', '1f', v);
      }, this, -50, 50);
      addToGui(guiLight, props, 'lightY', function(v) {
        glsl.setUniform('uLightY', '1f', v);
      }, this, -50, 50);
      addToGui(guiLight, props, 'lightZ', function(v) {
        glsl.setUniform('uLightZ', '1f', v);
      }, this, -50, 50);

      // adding switches for project 9
      const guiIllumation = gui.addFolder('Image Based Illumination');
      addToGui(guiIllumation, props, 'ambientOcclusion', function(v) {
        if (v) {
            console.log('ambient occlusion');
            glsl.setUniform('uFinalGatheringVersion', '1i', 0);
        }
        else {
            glsl.setUniform('uFinalGatheringVersion', '1i', 4);
        }
      }, this);
      addToGui(guiIllumation, props, 'environmentIllumination', function(v) {
        if (v) {
            console.log('environment illumination');
            glsl.setUniform('uFinalGatheringVersion', '1i', 1);
        }
        else {
        glsl.setUniform('uFinalGatheringVersion', '1i', 4);
        }
      }, this);
      addToGui(guiIllumation, props, 'colorBleeding', function(v) {
        if (v) {
            console.log('color bleeding');
            glsl.setUniform('uFinalGatheringVersion', '1i', 2);
        }
        else {
            glsl.setUniform('uFinalGatheringVersion', '1i', 4);
        }
      }, this);
      addToGui(guiIllumation, props, 'caustics', function(v) {
        if (v) {
            console.log('caustics');
            glsl.setUniform('uFinalGatheringVersion', '1i', 3);
        }
        else {
            glsl.setUniform('uFinalGatheringVersion', '1i', 4);
        }
      }, this);

      const guiColors = gui.addFolder('Object Colors');
      // TODO: FIGURE OUT COLORS :DD
      addColorToGui(guiColors, props, 'skyColor', function(v) {
        glsl.setUniform('uSkyColor', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);
      addColorToGui(guiColors, props, 'groundColor', function(v) {
        glsl.setUniform('uGroundColor', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);
      addColorToGui(guiColors, props, 'sphere1color', function(v) {
        glsl.setUniform('uSphere1Color', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);
      addColorToGui(guiColors, props, 'sphere2color', function(v) {
        glsl.setUniform('uSphere2Color', '3fv', [v[0]/255.0, v[1]/255.0, v[2]/255.0]);
      }, this);

      addToGui(gui, props, 'samples', function(v) {
        glsl.setUniform('uSamples', '1i', v);
      }, this, 1, 100);

      glsl.setUniform('uCameraPosition', '1f', props.cameraPosition);
      glsl.setUniform('uFieldOfView', '1f', props.fieldOfView);
      glsl.setUniform('uCameraHeight', '1f', props.cameraHeight);
      glsl.setUniform('uFocus', '1f', props.focus);
      glsl.setUniform('uAperture', '1f', props.aperture);
      glsl.setUniform('uGroundColor', '3fv', [props.groundColor[0] / 255.0, props.groundColor[1] / 255.0, props.groundColor[2] / 255.0]);
      glsl.setUniform('uSkyColor', '3fv', [props.skyColor[0] / 255.0, props.skyColor[1] / 255.0, props.skyColor[2] / 255.0]);
      glsl.setUniform('uSphere1Color', '3fv', [props.sphere1color[0] / 255.0, props.sphere1color[1] / 255.0, props.sphere1color[2] / 255.0]);
      glsl.setUniform('uSphere2Color', '3fv', [props.sphere2color[0] / 255.0, props.sphere2color[1] / 255.0, props.sphere2color[2] / 255.0]);
      glsl.setUniform('uMetalColor', '3fv', [props.metalColor[0] / 255.0, props.metalColor[1] / 255.0, props.metalColor[2] / 255.0]);
      glsl.setUniform('uFuzziness', '1f', props.fuzziness);
      glsl.setUniform('uSamples', '1i', props.samples);
      glsl.setUniform('uFinalGatheringVersion', '1i', 4);
      glsl.setTexture('uRandomTexture', './textures/rgb_noise.bmp');
      glsl.setTexture('uFloorTexture', './textures/broken_wall_diff_2k.jpg');
      glsl.setTexture('uFloorNormal', './textures/broken_wall_nor_gl_2k.png');
      glsl.setTexture('uSphereEnvironment', './textures/solitude_night_4k.png');
      glsl.start();
    });
  </script>
</body>
</html>
